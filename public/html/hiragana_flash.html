<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Hiragana Flash Cards (SRS + Review)</title>
  <style>
    :root { color-scheme: light dark; }
    * { box-sizing: border-box; }

    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Noto Sans","Apple Color Emoji","Segoe UI Emoji";
      display:grid;
      place-items:center;
      min-height:100vh;
      padding:24px;
      background:#0b0f17;
      color:#e7ecff;
    }

    .app{
      width:min(920px,100%);
      display:grid;
      gap:16px;
      justify-items:center;
    }

    h1{
      margin:0 0 4px 0;
      font-size:20px;
      font-weight:900;
      text-align:center;
      opacity:.95;
    }

    .sub{
      margin:0;
      font-size:14px;
      opacity:.75;
      text-align:center;
      line-height:1.35;
    }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size:11px;
      padding:2px 6px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
      opacity:.95;
      display:inline-block;
      margin:0 2px;
    }

    /* Card */
    .card-wrap{
      width:min(520px,100%);
      perspective:1200px;
    }
    .card{
      position:relative;
      width:100%;
      aspect-ratio:3/2; /* SAME front/back size */
      border-radius:18px;
      transform-style:preserve-3d;
      transition: transform 420ms cubic-bezier(.2,.8,.2,1);
      cursor:pointer;
      user-select:none;
      outline:none;
    }
    .card:focus-visible{ box-shadow:0 0 0 3px rgba(128,170,255,.6); }
    .card.is-flipped{ transform: rotateY(180deg); }

    /* Faces: identical sizing/layout */
    .face{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      border-radius:18px;

      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;

      backface-visibility:hidden;
      padding:0;

      background: linear-gradient(145deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
      border:1px solid rgba(255,255,255,.12);
      box-shadow:0 12px 40px rgba(0,0,0,.35);
      overflow:hidden;
    }
    .back{ transform: rotateY(180deg); }

    .inner{
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      gap:8px;
      padding:18px;
      text-align:center;
    }

    .front .kana,
    .back .kana{
      font-size: clamp(72px, 10.5vw, 120px);
      font-weight: 950;
      letter-spacing: .02em;
      line-height: 1;
    }

    .romaji{
      font-size:22px;
      font-weight:900;
      opacity:.9;
    }

    .hint{
      position:absolute;
      bottom:12px;
      left:0; right:0;
      text-align:center;
      font-size:12px;
      opacity:.55;
      pointer-events:none;
      padding:0 12px;
    }

    /* Controls / Stats */
    .controls{
      width:min(520px,100%);
      display:grid;
      gap:10px;
      justify-items:center;
    }

    .btn-row{
      display:none;
      width:100%;
      gap:10px;
      grid-template-columns:1fr 1fr;
    }
    .btn-row.show{ display:grid; }

    button{
      appearance:none;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(255,255,255,.08);
      color:inherit;
      padding:12px 14px;
      border-radius:12px;
      font-size:14px;
      font-weight:950;
      cursor:pointer;
      transition: transform 80ms ease, background 160ms ease, border-color 160ms ease, opacity 160ms ease;
    }
    button:hover{ background:rgba(255,255,255,.12); }
    button:active{ transform: translateY(1px); }
    button:focus-visible{ outline:none; box-shadow:0 0 0 3px rgba(128,170,255,.55); }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    .stats{
      width:100%;
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap:10px;
    }
    .stat{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.06);
      border-radius:14px;
      padding:10px 12px;
      text-align:center;
    }
    .stat .label{ font-size:12px; opacity:.7; }
    .stat .value{ margin-top:2px; font-size:18px; font-weight:950; }

    /* Moved 6 controls (2 mode buttons + 2 pills + 2 action buttons) */
    .toolbar-bottom{
      width:100%;
      display:grid;
      gap:10px;
      margin-top:2px;
    }
    .mode-row, .meta-row, .aux-row{
      width:100%;
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:10px;
    }

    .pill{
      border:1px solid rgba(255,255,255,.12);
      background:rgba(255,255,255,.05);
      border-radius:999px;
      padding:10px 12px;
      text-align:center;
      font-size:12px;
      opacity:.92;
      display:flex;
      align-items:center;
      justify-content:center;
      min-height: 44px;
    }

    .done{
      width:100%;
      display:none;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      border-radius:16px;
      padding:14px 16px;
      text-align:center;
      line-height:1.35;
    }
    .done.show{ display:block; }

    .footer{
      width:100%;
      display:grid;
      gap:8px;
      justify-items:center;
      margin-top:2px;
      opacity:.9;
    }

    .reset{
      font-size:13px;
      color:inherit;
      text-decoration:underline;
      cursor:pointer;
      opacity:.75;
    }
    .reset:hover{ opacity:1; }

    .small{
      font-size:12px;
      opacity:.7;
      text-align:center;
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Hiragana flash cards">

    <div>
      <h1>Hiragana Flash Cards</h1>
      <p class="sub">
        Click the card to flip and hear it (Text-to-Speech). Then mark <b>Right</b> or <b>Wrong</b>.<br/>
        <span class="kbd">Space</span>/<span class="kbd">Enter</span> flips,
        <span class="kbd">R</span> right,
        <span class="kbd">W</span> wrong
      </p>
    </div>

    <div class="card-wrap">
      <div id="card" class="card" tabindex="0" aria-label="Flash card">
        <div class="face front" aria-hidden="false">
          <div class="kana" id="frontKana">あ</div>
          <div class="hint">Click to flip • Space/Enter also works</div>
        </div>
        <div class="face back" aria-hidden="true">
          <div class="inner">
            <div class="kana" id="backKana">あ</div>
            <div class="romaji" id="romaji">a</div>
          </div>
          <div class="hint">Mark right/wrong to continue</div>
        </div>
      </div>
    </div>

    <div class="controls">
      <div id="btnRow" class="btn-row" aria-label="Answer buttons">
        <button id="btnRight" type="button">Right</button>
        <button id="btnWrong" type="button">Wrong</button>
      </div>

      <div class="stats" aria-label="Scoreboard">
        <div class="stat">
          <div class="label">Right</div>
          <div class="value" id="statRight">0</div>
        </div>
        <div class="stat">
          <div class="label">Wrong</div>
          <div class="value" id="statWrong">0</div>
        </div>
        <div class="stat">
          <div class="label">% Correct</div>
          <div class="value" id="statPct">0%</div>
        </div>
      </div>

      <!-- MOVED: the 6 controls go here (after stats, before reset) -->
      <div class="toolbar-bottom" aria-label="Mode and session controls">
        <div class="mode-row">
          <button id="btnModeSrs" type="button" aria-pressed="true">Spaced Repetition</button>
          <button id="btnModeReview" type="button" aria-pressed="false">Review All</button>
        </div>

        <div class="meta-row">
          <div id="pillA" class="pill">New remaining: 0</div>
          <div id="pillB" class="pill">Due now: 0</div>
        </div>

        <div class="aux-row">
          <button id="btnIntroduceNew" type="button">Introduce New Now</button>
          <button id="btnSkip" type="button">Skip (no score)</button>
        </div>
      </div>

      <div id="doneBox" class="done" role="status" aria-live="polite"></div>

      <div class="footer">
        <div id="resetLink" class="reset" role="button" tabindex="0" aria-label="Reset session">Reset session</div>
        <div class="small" id="modeHelp">
          Mode: Spaced repetition • “Introduce New Now” forces a never-seen card next
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------------------------
    // Full card set:
    // - basic gojūon
    // - dakuten / handakuten
    // - yōon combos (kya/kyu/kyo, nyo, etc.)
    // ---------------------------
    const BASE = [
      ["あ","a"],["い","i"],["う","u"],["え","e"],["お","o"],
      ["か","ka"],["き","ki"],["く","ku"],["け","ke"],["こ","ko"],
      ["さ","sa"],["し","shi"],["す","su"],["せ","se"],["そ","so"],
      ["た","ta"],["ち","chi"],["つ","tsu"],["て","te"],["と","to"],
      ["な","na"],["に","ni"],["ぬ","nu"],["ね","ne"],["の","no"],
      ["は","ha"],["ひ","hi"],["ふ","fu"],["へ","he"],["ほ","ho"],
      ["ま","ma"],["み","mi"],["む","mu"],["め","me"],["も","mo"],
      ["や","ya"],["ゆ","yu"],["よ","yo"],
      ["ら","ra"],["り","ri"],["る","ru"],["れ","re"],["ろ","ro"],
      ["わ","wa"],["を","wo"],["ん","n"]
    ];

    const DAKUTEN = [
      ["が","ga"],["ぎ","gi"],["ぐ","gu"],["げ","ge"],["ご","go"],
      ["ざ","za"],["じ","ji"],["ず","zu"],["ぜ","ze"],["ぞ","zo"],
      ["だ","da"],["ぢ","ji"],["づ","zu"],["で","de"],["ど","do"],
      ["ば","ba"],["び","bi"],["ぶ","bu"],["べ","be"],["ぼ","bo"]
    ];

    const HANDAKUTEN = [
      ["ぱ","pa"],["ぴ","pi"],["ぷ","pu"],["ぺ","pe"],["ぽ","po"]
    ];

    const YOON = [
      ["きゃ","kya"],["きゅ","kyu"],["きょ","kyo"],
      ["ぎゃ","gya"],["ぎゅ","gyu"],["ぎょ","gyo"],

      ["しゃ","sha"],["しゅ","shu"],["しょ","sho"],
      ["じゃ","ja"],["じゅ","ju"],["じょ","jo"],

      ["ちゃ","cha"],["ちゅ","chu"],["ちょ","cho"],

      ["にゃ","nya"],["にゅ","nyu"],["にょ","nyo"],

      ["ひゃ","hya"],["ひゅ","hyu"],["ひょ","hyo"],
      ["びゃ","bya"],["びゅ","byu"],["びょ","byo"],
      ["ぴゃ","pya"],["ぴゅ","pyu"],["ぴょ","pyo"],

      ["みゃ","mya"],["みゅ","myu"],["みょ","myo"],
      ["りゃ","rya"],["りゅ","ryu"],["りょ","ryo"]
    ];

    function buildAllCards(){
      const all = [...BASE, ...DAKUTEN, ...HANDAKUTEN, ...YOON];
      const seen = new Set();
      const out = [];
      for (const [kana, romaji] of all){
        const key = kana + "|" + romaji;
        if (seen.has(key)) continue;
        seen.add(key);
        out.push({ kana, romaji });
      }
      return out;
    }

    const ALL_CARDS = buildAllCards();

    // ---------------------------
    // DOM
    // ---------------------------
    const cardEl = document.getElementById("card");
    const frontKanaEl = document.getElementById("frontKana");
    const backKanaEl  = document.getElementById("backKana");
    const romajiEl    = document.getElementById("romaji");

    const btnRowEl    = document.getElementById("btnRow");
    const btnRightEl  = document.getElementById("btnRight");
    const btnWrongEl  = document.getElementById("btnWrong");

    const statRightEl = document.getElementById("statRight");
    const statWrongEl = document.getElementById("statWrong");
    const statPctEl   = document.getElementById("statPct");

    const pillAEl = document.getElementById("pillA");
    const pillBEl = document.getElementById("pillB");

    const btnModeSrsEl = document.getElementById("btnModeSrs");
    const btnModeReviewEl = document.getElementById("btnModeReview");
    const btnIntroduceNewEl = document.getElementById("btnIntroduceNew");
    const btnSkipEl = document.getElementById("btnSkip");

    const doneBoxEl = document.getElementById("doneBox");
    const resetLinkEl = document.getElementById("resetLink");
    const modeHelpEl = document.getElementById("modeHelp");

    // ---------------------------
    // TTS (Option B)
    // ---------------------------
    function getJapaneseVoice(){
      const voices = window.speechSynthesis?.getVoices?.() || [];
      return voices.find(v => (v.lang || "").toLowerCase().startsWith("ja")) || null;
    }

    let cachedJaVoice = null;

    function speakKana(kanaText){
      if (!("speechSynthesis" in window)) return;

      if (!cachedJaVoice) cachedJaVoice = getJapaneseVoice();

      const u = new SpeechSynthesisUtterance(kanaText);
      u.lang = "ja-JP";
      u.rate = 0.95;
      u.pitch = 1.0;
      if (cachedJaVoice) u.voice = cachedJaVoice;

      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    }

    function primeVoices(){
      if (!("speechSynthesis" in window)) return;
      window.speechSynthesis.getVoices();
    }

    if ("speechSynthesis" in window){
      window.speechSynthesis.onvoiceschanged = () => {
        cachedJaVoice = getJapaneseVoice();
      };
    }

    // ---------------------------
    // Shared state + helpers
    // ---------------------------
    const MODE = { SRS: "srs", REVIEW: "review" };
    let mode = MODE.SRS;

    let right = 0;
    let wrong = 0;

    let currentCard = null;
    let isFlipped = false;
    let finished = false;

    function setCard(card){
      currentCard = card;
      frontKanaEl.textContent = card.kana;
      backKanaEl.textContent = card.kana;
      romajiEl.textContent = card.romaji;
    }

    function setFlipped(flip){
      isFlipped = flip;
      cardEl.classList.toggle("is-flipped", flip);
      btnRowEl.classList.toggle("show", flip && !finished);

      const faces = cardEl.querySelectorAll(".face");
      faces[0].setAttribute("aria-hidden", flip ? "true" : "false");
      faces[1].setAttribute("aria-hidden", flip ? "false" : "true");
    }

    function updateStats(){
      const total = right + wrong;
      const pct = total === 0 ? 0 : Math.round((right / total) * 100);
      statRightEl.textContent = String(right);
      statWrongEl.textContent = String(wrong);
      statPctEl.textContent = `${pct}%`;
    }

    function showDone(html){
      doneBoxEl.innerHTML = html;
      doneBoxEl.classList.add("show");
    }
    function hideDone(){
      doneBoxEl.classList.remove("show");
      doneBoxEl.textContent = "";
    }

    function shuffle(arr){
      for (let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    // ---------------------------
    // REVIEW MODE (no spaced repetition)
    // - Show all cards once in random order
    // ---------------------------
    let reviewDeck = [];
    let reviewPos = 0;

    function resetReview(){
      reviewDeck = shuffle([...Array(ALL_CARDS.length).keys()]);
      reviewPos = 0;
    }

    function updateReviewMeta(){
      const remaining = Math.max(0, reviewDeck.length - reviewPos);
      const done = Math.min(reviewPos, reviewDeck.length);
      pillAEl.textContent = `Remaining in review: ${remaining}`;
      pillBEl.textContent = `Reviewed: ${done}/${reviewDeck.length}`;
    }

    function nextReviewCard(){
      updateReviewMeta();

      if (reviewPos >= reviewDeck.length){
        finished = true;
        setFlipped(false);

        const total = right + wrong;
        const pct = total === 0 ? 0 : Math.round((right / total) * 100);

        showDone(
          `✅ Review complete.<br/>` +
          `Final score: <strong>${right}</strong> right, <strong>${wrong}</strong> wrong — <strong>${pct}%</strong> correct.<br/>` +
          `Cards reviewed: <strong>${reviewDeck.length}</strong>.`
        );
        return;
      }

      const idx = reviewDeck[reviewPos++];
      setCard(ALL_CARDS[idx]);
      setFlipped(false);
      updateReviewMeta();
      cardEl.focus({ preventScroll:true });
    }

    // ---------------------------
    // SRS MODE (session-based spaced repetition)
    // - Fixes “stops introducing new” by mixing in new cards regularly
    // - “Introduce New Now” forces a new unseen card next (and jumps immediately)
    // ---------------------------
    const SCHEDULE_STEPS = [1,2,4,8,16,32]; // due after N answers
    const MASTERED_STAGE = 4;

    const INTRO_EVERY = 3;  // at least one new every N answers (while any new remain)
    const DUE_SMALL = 2;    // if due is small, favor new
    const RANDOM_NEW_CHANCE = 0.15;

    let tick = 0;
    let answersSinceNew = 0;
    let forceIntroduceNewNext = false;

    // card state:
    // { id, kana, romaji, stage, dueTick, introduced, lapses, introRank }
    let srsCards = [];

    function resetSrs(){
      tick = 0;
      answersSinceNew = 0;
      forceIntroduceNewNext = false;

      srsCards = ALL_CARDS.map((c, idx) => ({
        id: idx,
        kana: c.kana,
        romaji: c.romaji,
        stage: 0,
        dueTick: 0,
        introduced: false,
        lapses: 0,
        introRank: 0
      }));

      const order = shuffle(srsCards.map(c => c.id));
      for (let i = 0; i < order.length; i++){
        srsCards[order[i]].introRank = i;
      }
    }

    function countNewRemaining(){
      return srsCards.filter(c => !c.introduced).length;
    }
    function countDue(){
      return srsCards.filter(c => c.introduced && c.dueTick <= tick).length;
    }

    function updateSrsMeta(){
      pillAEl.textContent = `New remaining: ${countNewRemaining()}`;
      pillBEl.textContent = `Due now: ${countDue()}`;
      btnIntroduceNewEl.disabled = countNewRemaining() === 0;
    }

    function isSrsComplete(){
      return countNewRemaining() === 0 && countDue() === 0;
    }

    function getNextNewCard(){
      const unseen = srsCards
        .filter(c => !c.introduced)
        .sort((a,b) => a.introRank - b.introRank);
      return unseen.length ? unseen[0] : null;
    }

    function getDueCards(){
      return srsCards.filter(c => c.introduced && c.dueTick <= tick);
    }

    function shouldIntroduceNew(dueCount){
      if (countNewRemaining() === 0) return false;
      if (dueCount === 0) return true;
      if (dueCount <= DUE_SMALL) return true;
      if (answersSinceNew >= INTRO_EVERY) return true;
      return Math.random() < RANDOM_NEW_CHANCE;
    }

    function pickNextSrsCard(){
      if (forceIntroduceNewNext){
        forceIntroduceNewNext = false;
        const n = getNextNewCard();
        if (n) return n;
        // if none left, fall through
      }

      const due = getDueCards();
      const dueCount = due.length;

      if (shouldIntroduceNew(dueCount)){
        const n = getNextNewCard();
        if (n) return n;
      }

      if (dueCount > 0){
        // Weighted toward lower stage
        const weights = due.map(c => (MASTERED_STAGE + 2) - Math.min(c.stage, MASTERED_STAGE + 1));
        const totalW = weights.reduce((a,b)=>a+b,0);
        let r = Math.random() * totalW;
        for (let i = 0; i < due.length; i++){
          r -= weights[i];
          if (r <= 0) return due[i];
        }
        return due[due.length - 1];
      }

      return getNextNewCard();
    }

    function scheduleAfterAnswer(card, wasRight){
      if (wasRight){
        card.stage = Math.min(card.stage + 1, SCHEDULE_STEPS.length);
        const idx = Math.min(card.stage - 1, SCHEDULE_STEPS.length - 1);
        const delay = SCHEDULE_STEPS[Math.max(0, idx)];
        card.dueTick = tick + delay;
      } else {
        card.lapses += 1;
        card.stage = 0;
        card.dueTick = tick + 1; // show again soon
      }
    }

    function nextSrsCard(){
      updateSrsMeta();

      if (isSrsComplete()){
        finished = true;
        setFlipped(false);

        const total = right + wrong;
        const pct = total === 0 ? 0 : Math.round((right / total) * 100);
        const learned = srsCards.filter(c => c.stage >= MASTERED_STAGE).length;

        showDone(
          `✅ SRS session complete.<br/>` +
          `Score: <strong>${right}</strong> right, <strong>${wrong}</strong> wrong — <strong>${pct}%</strong> correct.<br/>` +
          `Learned this session: <strong>${learned}/${srsCards.length}</strong> (stage ≥ ${MASTERED_STAGE}).`
        );
        return;
      }

      const next = pickNextSrsCard();
      if (!next){
        finished = true;
        setFlipped(false);
        showDone(`✅ SRS session complete.`);
        return;
      }

      const wasNew = !next.introduced;
      if (wasNew){
        next.introduced = true;
        next.dueTick = tick;     // due now (we are showing it now)
        answersSinceNew = 0;     // reset drought counter
      }

      setCard(next);
      setFlipped(false);
      updateSrsMeta();
      cardEl.focus({ preventScroll:true });
    }

    // ---------------------------
    // Mode switching + flow
    // ---------------------------
    function setMode(newMode){
      mode = newMode;

      btnModeSrsEl.setAttribute("aria-pressed", mode === MODE.SRS ? "true" : "false");
      btnModeReviewEl.setAttribute("aria-pressed", mode === MODE.REVIEW ? "true" : "false");

      if (mode === MODE.SRS){
        btnIntroduceNewEl.style.display = "";
        modeHelpEl.textContent = "Mode: Spaced repetition • “Introduce New Now” forces a never-seen card next";
      } else {
        btnIntroduceNewEl.style.display = "none";
        modeHelpEl.textContent = "Mode: Review all • Shows every card once in random order (no spaced repetition)";
      }

      resetSession();
    }

    function nextCard(){
      if (finished) return;
      if (mode === MODE.REVIEW) nextReviewCard();
      else nextSrsCard();
    }

    function flipCard(){
      if (finished) return;
      const goingToBack = !isFlipped;
      setFlipped(!isFlipped);

      if (goingToBack && currentCard?.kana){
        speakKana(currentCard.kana);
      }
    }

    function answer(isRight){
      if (finished) return;
      if (!isFlipped) return;

      if (isRight) right++;
      else wrong++;

      if (mode === MODE.REVIEW){
        updateStats();
        nextCard();
        return;
      }

      // SRS
      tick += 1;               // one step per answered card
      answersSinceNew += 1;

      scheduleAfterAnswer(currentCard, isRight);

      updateStats();
      nextCard();
    }

    function skipNoScore(){
      if (finished) return;
      // Skip does not increment score, and does not increment SRS tick.
      nextCard();
    }

    function resetSession(){
      if ("speechSynthesis" in window) window.speechSynthesis.cancel();

      right = 0;
      wrong = 0;
      updateStats();
      hideDone();

      finished = false;

      if (mode === MODE.REVIEW){
        resetReview();
        updateReviewMeta();
        nextReviewCard();
      } else {
        resetSrs();
        updateSrsMeta();
        nextSrsCard();
      }
    }

    // ---------------------------
    // Events
    // ---------------------------
    cardEl.addEventListener("click", flipCard);

    cardEl.addEventListener("keydown", (e) => {
      if (e.key === " " || e.key === "Enter"){
        e.preventDefault();
        flipCard();
        return;
      }
      if (!finished && isFlipped){
        const k = e.key.toLowerCase();
        if (k === "r") answer(true);
        if (k === "w") answer(false);
      }
    });

    btnRightEl.addEventListener("click", () => answer(true));
    btnWrongEl.addEventListener("click", () => answer(false));

    btnSkipEl.addEventListener("click", skipNoScore);

    btnIntroduceNewEl.addEventListener("click", () => {
      if (mode !== MODE.SRS) return;
      if (countNewRemaining() === 0) return;
      forceIntroduceNewNext = true;
      // Immediately jump to a new card (no score, no tick)
      nextCard();
    });

    btnModeSrsEl.addEventListener("click", () => {
      if (mode !== MODE.SRS) setMode(MODE.SRS);
    });
    btnModeReviewEl.addEventListener("click", () => {
      if (mode !== MODE.REVIEW) setMode(MODE.REVIEW);
    });

    resetLinkEl.addEventListener("click", resetSession);
    resetLinkEl.addEventListener("keydown", (e) => {
      if (e.key === " " || e.key === "Enter"){
        e.preventDefault();
        resetSession();
      }
    });

    // ---------------------------
    // Init
    // ---------------------------
    (function init(){
      primeVoices();
      setMode(MODE.SRS); // default
    })();
  </script>
</body>
</html>
